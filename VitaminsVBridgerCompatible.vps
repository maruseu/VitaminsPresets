{"version":"0.9.7","customParam":[{"func":"let result = headRotY\nlet inmin=-40.0, inmax=40;         //input range\nlet outmin=-40.0, outmax=40.0;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":40,"min":-40,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FaceAngleX"},{"func":"let result = ( - ((-headRotX * ((90 - Math.abs(headRotY)) / 90)) + (-headRotZ * (headRotY / 45))))\nlet inmin=-40.0, inmax=40;         //input range\nlet outmin=-40.0, outmax=40.0;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":40,"min":-40,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FaceAngleY"},{"func":"let result = ((headRotZ * ((90 - Math.abs(headRotY)) / 90)) - (headRotX * (headRotY / 45)))\nlet inmin=-40.0, inmax=40;         //input range\nlet outmin=-40.0, outmax=40.0;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":40,"min":-40,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FaceAngleZ"},{"func":"return headPosX * - 1","max":15,"min":-15,"default":0,"type":"simple","sendFlag":"true","paramName":"param_FacePositionX"},{"func":"return headPosY","max":15,"min":-15,"default":0,"type":"simple","sendFlag":"true","paramName":"param_FacePositionY"},{"func":"return headPosZ","max":15,"min":-15,"default":0,"type":"simple","sendFlag":"true","paramName":"param_FacePositionZ"},{"func":"let result = ((jawOpen - mouthClose) - ((mouthRollUpper + mouthRollLower) * .2) + (mouthFunnel * .2))\nlet inmin=0.0, inmax=1.0;         //input range\nlet outmin=0.0, outmax=1.0;     //output range\nlet x1=.24,y1=.65;     // bezier control point 1\nlet x2=.62,y2=1.0;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":1,"min":0,"default":0,"type":"complex","sendFlag":"true","paramName":"param_MouthOpen"},{"func":"return (eyeLookIn_L - .1) - eyeLookOut_L","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeRightX"},{"func":"return (eyeLookUp_L - eyeLookDown_L) + (browOuterUp_L * .15) + (headRotX / 30)","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeRightY"},{"func":"return .5 + ((eyeBlink_L * - .8) + (eyeWide_L * .8))","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeOpenLeft"},{"func":"return .5 + ((eyeBlink_R * - .8) + (eyeWide_R * .8))","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeOpenRight"},{"func":"return (2 - ((mouthFrown_L + mouthFrown_R + mouthPucker) / 1) + ((mouthSmile_R + mouthSmile_L + ((mouthDimple_L + mouthDimple_R) / 2)) / 1)) / 4","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthSmile"},{"func":"return (eyeSquint_L)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_Eye_Squint_L"},{"func":"return (eyeSquint_R)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_Eye_Squint_R"},{"func":"return (((mouthLeft - mouthRight) + (mouthSmile_L - mouthSmile_R)) * (1 - tongueOut))","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthX"},{"func":"return cheekPuff","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_CheekPuff"},{"func":"return tongueOut","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_TongueOut"},{"func":"return ((jawOpen - mouthClose) - ((mouthRollUpper + mouthRollLower) * .2) + (mouthFunnel * .2))","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_VoiceVolumePlusMouthOpen"},{"func":"return (((mouthDimple_R + mouthDimple_L) * 2) - mouthPucker) * (1 - tongueOut)","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthPucker"},{"func":"return (mouthFunnel * (1 - tongueOut)) - (jawOpen * .2)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthFunnel"},{"func":"return jawOpen","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_JawOpen"},{"func":"let result = (((mouthUpperUp_R + mouthUpperUp_L + mouthLowerDown_R + mouthLowerDown_L) / 1.8) - (mouthRollLower + mouthRollUpper)) * (1 - tongueOut)\nlet inmin=-1.3, inmax=1.3;         //input range\nlet outmin=-1.3, outmax=1.3;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":1.3,"min":-1.3,"default":0,"type":"complex","sendFlag":"true","paramName":"param_MouthPressLipOpen"},{"func":"return ((mouthShrugUpper + mouthShrugLower + mouthPress_R + mouthPress_L) / 4) * (1 - tongueOut)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthShrug"},{"func":"return browInnerUp","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BrowInnerUp"},{"func":"return .5 + (browOuterUp_L - browDown_L) + ((mouthRight - mouthLeft) / 8)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BrowLeftY"},{"func":"return .5 + (browOuterUp_R - browDown_R) + ((mouthLeft - mouthRight) / 8)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BrowRightY"},{"func":"return .5 + (browOuterUp_R + browOuterUp_L - browDown_L - browDown_R) / 4","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_Brows"},{"func":"return (2 - ((mouthFrown_L + mouthFrown_R + mouthPucker) / 1) + ((mouthSmile_R + mouthSmile_L + ((mouthDimple_L + mouthDimple_R) / 2)) / 1)) / 4","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_VoiceFrequencyPlusMouthSmile"},{"func":"return headRotY * 1.5","max":40,"min":-40,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BodyAngleX"},{"func":"return ( headRotX * 1.5)  + ( (eyeBlink_L + eyeBlink_R) * - 1)","max":40,"min":-40,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BodyAngleY"},{"func":"return headRotZ * 1.5","max":40,"min":-40,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BodyAngleZ"}],"author":"Maruseu","description":"","saveName":"VBridgerCompatible","isDefault":false}