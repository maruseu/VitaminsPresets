{"version":"0.9.7","customParam":[{"func":"let result = headRotY\nlet inmin=-40.0, inmax=40;         //input range\nlet outmin=-30.0, outmax=30.0;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":30,"min":-30,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FaceAngleX"},{"func":"let result = ( - ((-headRotX * ((90 - Math.abs(headRotY)) / 90)) + (-headRotZ * (headRotY / 45))))\nlet inmin=-40.0, inmax=40;         //input range\nlet outmin=-30.0, outmax=30.0;     //output range\nlet x1=.65,y1=.0;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":30,"min":-30,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FaceAngleY"},{"func":"let result = ((headRotZ * ((90 - Math.abs(headRotY)) / 90)) - (headRotX * (headRotY / 45)))\nlet inmin=-30.0, inmax=30;         //input range\nlet outmin=-30.0, outmax=30.0;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":30,"min":-30,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FaceAngleZ"},{"func":"return headPosX * - 1//+((ref.FaceAngleX+30)/60*8)","max":15,"min":-15,"default":0,"type":"simple","sendFlag":"true","paramName":"param_FacePositionX"},{"func":"/*let result = headPosY+((ref.FaceAngleY+30)/60*8)\nreturn result\n*/\nlet p=ref.FaceAngleY;\nlet s=2.0;        //smoothing\nlet dC=8;        //delay counter\nlet inmin=-30.0, inmax=30;         //input range\nlet outmin=-10.0, outmax=10.0;     //output range\np=(((p+inmin)/(inmax-inmin))*(outmax-outmin))-outmin\nif(this.f==undefined)\n    this.f=0;\nif(this.v==undefined)\n    this.v=0;\nif(this.d==undefined){\n    this.d=[];\n    for(let i=0; i<dC; i++)\n        this.d[i]=0;\n}\n\nthis.d[this.f]=p;\n\nthis.f=(this.f+1)%dC;\n\nreturn this.v+=(this.d[this.f]-this.v)/s;","max":15,"min":-15,"default":0,"type":"complex","sendFlag":"true","paramName":"param_FacePositionY"},{"func":"return headPosZ//+((ref.FaceAngleY+30)/60*2)","max":15,"min":-15,"default":0,"type":"simple","sendFlag":"true","paramName":"param_FacePositionZ"},{"func":"let result = ((jawOpen - mouthClose) - ((mouthRollUpper + mouthRollLower) * .2) + (mouthFunnel * .2))\nlet inmin=0.0, inmax=1.0;         //input range\nlet outmin=0.0, outmax=1.0;     //output range\nlet x1=.24,y1=.65;     // bezier control point 1\nlet x2=.62,y2=1.0;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":1,"min":0,"default":0,"type":"complex","sendFlag":"true","paramName":"param_MouthOpen"},{"func":"return (eyeLookIn_L - .1) - eyeLookOut_L","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeRightX"},{"func":"return (eyeLookUp_L - eyeLookDown_L) + (browOuterUp_L * .15) + (headRotX / 30)","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeRightY"},{"func":"return (.5 + ((eyeBlink_L * - .8) + (eyeWide_L * .8)))-eyeSquint_L*.2","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeOpenLeft"},{"func":"return (.5 + ((eyeBlink_R * - .8) + (eyeWide_R * .8)))-eyeSquint_R*.2","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_EyeOpenRight"},{"func":"return (2 - ((mouthFrown_L + mouthFrown_R + mouthPucker) / 1) + ((mouthSmile_R + mouthSmile_L + ((mouthDimple_L + mouthDimple_R) / 2)) / 1)) / 4","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthSmile"},{"func":"return (eyeSquint_L)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_Eye_Squint_L"},{"func":"return (eyeSquint_R)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_Eye_Squint_R"},{"func":"return (((mouthLeft - mouthRight) + (mouthSmile_L - mouthSmile_R)) * (1 - tongueOut))","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthX"},{"func":"return cheekPuff","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_CheekPuff"},{"func":"return tongueOut","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_TongueOut"},{"func":"return ((jawOpen - mouthClose) - ((mouthRollUpper + mouthRollLower) * .2) + (mouthFunnel * .2))","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_VoiceVolumePlusMouthOpen"},{"func":"return (((mouthDimple_R + mouthDimple_L) * 2) - mouthPucker) * (1 - tongueOut)","max":1,"min":-1,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthPucker"},{"func":"return (mouthFunnel * (1 - tongueOut)) - (jawOpen * .2)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthFunnel"},{"func":"return jawOpen","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_JawOpen"},{"func":"let result = (((mouthUpperUp_R + mouthUpperUp_L + mouthLowerDown_R + mouthLowerDown_L) / 1.8) - (mouthRollLower + mouthRollUpper)) * (1 - tongueOut)\nlet inmin=-1.3, inmax=1.3;         //input range\nlet outmin=-1.3, outmax=1.3;     //output range\nlet x1=.54,y1=.03;     // bezier control point 1\nlet x2=1-x1,y2=1-y1;    // bezier control point 2\n\nlet points = 10000;        // points loaded\nlet lowP = 62;             // low precision points saved\n\nlet t=Math.min(Math.max(result,inmin),inmax);\nt-=inmin;\nt/=(inmax-inmin);\nif(this.lowPP==undefined){ // calc curve points\n    let lowPDiv=1.0/lowP;\n    let curLowP=1;\n    this.lowPP=[];\n    this.lowPP[0]=0;\n    for(let i=0;i<points;i++){\n        let t=i/points; let u=1-t;\n        let x=3*u*u*t*x1+3*u*t*t*x2+t*t*t;\n        let y=3*u*u*t*y1+3*u*t*t*y2+t*t*t;\n        if(x>(lowPDiv*curLowP)){\n            this.lowPP[curLowP]=y;\n            curLowP++;\n        }\n    }\n    this.lowPP[lowP]=1;this.lowPP[lowP+1]=1;\n}\nlet lowPoint=Math.floor(t*lowP);\nresult=this.lowPP[lowPoint]*(1-(t*lowP%1))+\nthis.lowPP[lowPoint+1]*(t*lowP%1);\nresult*=(outmax-outmin);\nresult+=outmin;\nreturn result","max":1.3,"min":-1.3,"default":0,"type":"complex","sendFlag":"true","paramName":"param_MouthPressLipOpen"},{"func":"return ((mouthShrugUpper + mouthShrugLower + mouthPress_R + mouthPress_L) / 4) * (1 - tongueOut)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_MouthShrug"},{"func":"return browInnerUp","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BrowInnerUp"},{"func":"return .5 + (browOuterUp_L - browDown_L) + ((mouthRight - mouthLeft) / 8)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BrowLeftY"},{"func":"return .5 + (browOuterUp_R - browDown_R) + ((mouthLeft - mouthRight) / 8)","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_BrowRightY"},{"func":"return .5 + (browOuterUp_R + browOuterUp_L - browDown_L - browDown_R) / 4","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_Brows"},{"func":"return (2 - ((mouthFrown_L + mouthFrown_R + mouthPucker) / 1) + ((mouthSmile_R + mouthSmile_L + ((mouthDimple_L + mouthDimple_R) / 2)) / 1)) / 4","max":1,"min":0,"default":0,"type":"simple","sendFlag":"true","paramName":"param_VoiceFrequencyPlusMouthSmile"},{"func":"let p=ref.FaceAngleX;\nlet s=2.0;        //smoothing\nlet dC=8;        //delay counter\nlet inmin=-30.0, inmax=30;         //input range\nlet outmin=-10.0, outmax=10.0;     //output range\np=(((p+inmin)/(inmax-inmin))*(outmax-outmin))-outmin\nif(this.f==undefined)\n    this.f=0;\nif(this.v==undefined)\n    this.v=0;\nif(this.d==undefined){\n    this.d=[];\n    for(let i=0; i<dC; i++)\n        this.d[i]=0;\n}\n\nthis.d[this.f]=p;\n\nthis.f=(this.f+1)%dC;\n\nreturn this.v+=(this.d[this.f]-this.v)/s;","max":10,"min":-10,"default":0,"type":"complex","sendFlag":"true","paramName":"param_BodyAngleX"},{"func":"let p=ref.FaceAngleY;\nlet s=2.0;        //smoothing\nlet dC=8;        //delay counter\nlet inmin=-30.0, inmax=30;         //input range\nlet outmin=-10.0, outmax=10.0;     //output range\np=(((p+inmin)/(inmax-inmin))*(outmax-outmin))-outmin\nif(this.f==undefined)\n    this.f=0;\nif(this.v==undefined)\n    this.v=0;\nif(this.d==undefined){\n    this.d=[];\n    for(let i=0; i<dC; i++)\n        this.d[i]=0;\n}\n\nthis.d[this.f]=p;\n\nthis.f=(this.f+1)%dC;\n\nreturn this.v+=(this.d[this.f]-this.v)/s;","max":10,"min":-10,"default":0,"type":"complex","sendFlag":"true","paramName":"param_BodyAngleY"},{"func":"let p=ref.FaceAngleZ;\nlet s=2.0;        //smoothing\nlet dC=4;        //delay counter\nlet inmin=-30.0, inmax=30;         //input range\nlet outmin=-10.0, outmax=10.0;     //output range\np=(((p+inmin)/(inmax-inmin))*(outmax-outmin))-outmin\nif(this.f==undefined)\n    this.f=0;\nif(this.v==undefined)\n    this.v=0;\nif(this.d==undefined){\n    this.d=[];\n    for(let i=0; i<dC; i++)\n        this.d[i]=0;\n}\n\nthis.d[this.f]=p;\n\nthis.f=(this.f+1)%dC;\n\nreturn this.v+=(this.d[this.f]-this.v)/s;","max":40,"min":-40,"default":0,"type":"complex","sendFlag":"true","paramName":"param_BodyAngleZ"}],"author":"Maruseu","description":"","saveName":"VBridgerCompatibleMaruVer","isDefault":false}